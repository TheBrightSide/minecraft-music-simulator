# options.json - settings for the player
# musicMapping.json - mapping for music files (i recommend you to not change it)
# leftover.json - queue progression (generated by program)

import simpleaudio
from pyogg import VorbisFile
import time
import os
import sys
import signal
import logging
from funcs import *
from constants import *
from random import randint, shuffle

logging.basicConfig(level=logging.DEBUG)
log = logging.getLogger('main-thread')

log.debug(f'Current Directory: {os.getcwd()}')

def onKeyboardInterrupt(signal, frame):
    log.info('Issued KeyboardInterrupt!')
    if settings["saveProgress"]:
        log.info('Saving queue progress in leftover.json...')
        log.debug(f'Writing data: {progress}')
        writeJsonFile('leftover.json', progress)
    else:
        log.warning('Progression saving and loading is disabled! You can change it in options.json by changing "saveProgress" in options.json')
    sys.exit(0)

# load configuration files
settings = readJsonFile('options.json')
musicMapping = readJsonFile('musicMapping.json')
progress = { "index": 0, "categoryIndex": 0 }
if os.path.exists('leftover.json'):
    if settings["saveProgress"]:
        log.debug('leftover.json exists, reading...')
        progress = readJsonFile('leftover.json')
        log.debug(f'Read: category index - {progress["categoryIndex"]}, index - {progress["index"]}')
    else:
        log.warning('Progression saving and loading is disabled! You can change it in options.json by changing "saveProgress" in options.json')
elif not settings["saveProgress"]:
    log.warning('Progression saving and loading is disabled! You can change it in options.json by changing "saveProgress" in options.json')
else:
    log.debug('leftover.json doesn\'t exist, creation on exit')

signal.signal(signal.SIGINT, onKeyboardInterrupt)
def main():
    # category loop (loops through every category)
    for categoryIndex, category in enumerate(settings["categoryOrder"][progress["categoryIndex"]:], start=progress["categoryIndex"]):
        log.info(f'Switching to category {category}')
        progress["categoryIndex"] = categoryIndex

        music_filenames = musicMapping[category]["survival"]
        music_filenames = music_filenames[progress["index"]:]
        log.debug(f'Found {len(music_filenames)} filenames!')
        log.debug(f'Filenames: {music_filenames}')

        if not musicMapping[category]["inOrder"]:
            log.debug('List must be shuffled!')
            log.debug('Shuffling...')
            shuffle(music_filenames)
            log.debug(f'Shuffled! {music_filenames}')
        else:
            log.debug('List mustn\'t be shuffled, proceeding...')
        
        log.debug(f'Adding root ({settings["musicRootDir"]}) to filenames...')
        music_filenames = addRootArray(music_filenames, settings["musicRootDir"])

        # filename loop (loops through the shuffled/not shuffled filenames that are prewritten in musicMapping.json)
        for index, filename in enumerate(music_filenames, start=progress["index"]):
            progress["index"] = index
            log.debug(f'category index - {categoryIndex}, track index - {index}')

            # checks if the category is 'menu' (the menu music usually has shorter pauses between the music)
            if not category == 'menu':
                timeout = randint(settings["playingTimeInterval"][0], settings["playingTimeInterval"][1])
            else:
                timeout = randint(settings["menuTimeInterval"][0], settings["menuTimeInterval"][1])
            
            log.info(f'Timeout for {timeout}s')
            time.sleep(timeout)
            log.info(f'Playing {filename}')
            
            try:
                audioData = VorbisFile(filename)
                log.debug(f'channels - {audioData.channels}, frequency - {audioData.frequency}, buffer length - {audioData.buffer_length}')
            except Exception as e:
                log.error(f'File doesn\'t exist, proceeding...')
                log.error(e)
                continue
            
            play_obj = simpleaudio.play_buffer(audioData.buffer, audioData.channels, 2, audioData.frequency)
            play_obj.wait_done()

    log.info(f'End of queue')

    log.info('Resetting leftover.json...')
    writeJsonFile('leftover.json', {"index": 0, "categoryIndex": 0})

if __name__ == '__main__':
    main()