# options.json - settings for the player
# musicMapping.json - mapping for music files (i recommend you to not change it)
# leftover.json - queue progression (generated by program)

# Logging levels
# CRITICAL 50
# ERROR 40
# WARNING 30
# INFO 20
# DEBUG 10
# NOTSET 0

import simpleaudio
from pyogg import VorbisFile
import json
import time
import os
import sys
import signal
import logging
from random import randint, shuffle

logging.basicConfig(level=logging.DEBUG)
log = logging.getLogger('main-thread')

log.debug(f'Current Directory: {os.getcwd()}')

def readJsonFile(path):
    f = open(path)
    data = json.load(f)
    f.close()
    return data

def writeJsonFile(path, data):
    f = open(path, 'w')
    json.dump(data, f)
    f.close
    return

settings = readJsonFile('options.json')
musicMapping = readJsonFile('musicMapping.json')
readProgress = { "index": 0, "categoryIndex": 0 }
if os.path.exists('leftover.json'):
    if settings["saveProgress"]:
        log.debug('leftover.json exists, reading...')
        readProgress = readJsonFile('leftover.json')
        log.debug(f'Read: category index - {readProgress["categoryIndex"]}, index - {readProgress["index"]}')
    else:
        log.debug('Progression saving and loading is disabled! You can change it in options.json by changing "saveProgress" in options.json')
else:
    log.debug('leftover.json doesn\'t exist, creation on exit')
writeProgress = readProgress

def onKeyboardInterrupt(signal, frame):
    log.info('Issued KeyboardInterrupt!')
    if settings["saveProgress"]:
        log.info('Saving queue progress in leftover.json...')
        log.debug(f'Writing data: {writeProgress}')
        writeJsonFile('leftover.json', writeProgress)
    else:
        log.debug('Progression saving and loading is disabled! You can change it in options.json by changing "saveProgress" in options.json')
    sys.exit(0)

def addRootArray(array, root):
    for i, e in enumerate(array):
        array[i] = os.path.join(os.getcwd(), root, array[i])
    return array

signal.signal(signal.SIGINT, onKeyboardInterrupt)
for categoryIndex, category in enumerate(settings["categoryOrder"][readProgress["categoryIndex"]:], start=readProgress["categoryIndex"]):
    writeProgress["categoryIndex"] = categoryIndex
    log.info(f'Switching to category {category}')
    music_filenames = musicMapping[category]["survival"]
    music_filenames = music_filenames[readProgress["index"]:]
    log.debug(f'Found {len(music_filenames)} filenames!')
    inOrder = musicMapping[category]["inOrder"]
    log.debug(f'Filenames: {music_filenames}')
    if not inOrder:
        log.debug('List should be shuffled!')
        log.debug('Shuffling...')
        shuffle(music_filenames)
        log.debug(f'Shuffled! {music_filenames}')
    else:
        log.debug('List shouldn\'t be shuffled, proceeding...')
    log.debug(f'Adding root ({settings["musicRootDir"]}) to filenames...')
    music_filenames = addRootArray(music_filenames, settings["musicRootDir"])
    for index, filename in enumerate(music_filenames, start=readProgress["index"]):
        writeProgress["index"] = index
        log.debug(f'category index - {categoryIndex}, track index - {index}')
        if not category == 'menu':
            timeout = randint(settings["playingTimeInterval"][0], settings["playingTimeInterval"][1])
        else:
            timeout = randint(settings["menuTimeInterval"][0], settings["menuTimeInterval"][1])
        log.info(f'Timeout for {timeout}s')
        time.sleep(timeout)
        log.info(f'Playing {filename}')
        try:
            audioData = VorbisFile(filename)
            log.debug(f'channels - {audioData.channels}, frequency - {audioData.frequency}, buffer length - {audioData.buffer_length}')
        except Exception as e:
            log.error(f'File doesn\'t exist, proceeding...')
            log.error(e)
            continue
        play_obj = simpleaudio.play_buffer(audioData.buffer, audioData.channels, 2, audioData.frequency)
        play_obj.wait_done()
    readProgress["index"] = 0
readProgress["categoryIndex"] = 0

log.info(f'End of queue')

log.info('Resetting leftover.json...')
writeJsonFile('leftover.json', readProgress)